
//Brute force 
//Time Complexity - O(n*n)

// class Solution {
// public:
//     int subarraySum(vector<int>& nums, int k) {
//         int n = nums.size();
//         int count=0;

//         for(int i = 0; i<n; i++){
//             int sum = 0;
//                 for(int j = i+0; j<n; j++){
//                     sum += nums[j];
//                     if(sum == k)count++;
//                 }
//         }
//         return count;
//     }
// };



//Optimum
//Time Complexity - O(n)
// Approuch - prefix sum and hashmaps

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
       int n = nums.size();
       int j =0;
       int count = 0;
       vector<int>prefSum(n, 0);
       prefSum[0] = nums[0];

       for(int i =1; i < n; i++){
        prefSum[i] = prefSum[i-1] + nums[i];
       }

        unordered_map<int,int>m;

        for(int j = 0; j<n; j++){

            if(prefSum[j] == k) count++;
            int val = prefSum[j]-k;
            if(m.find(val) != m.end() ){
                count += m[val];
            }
            if(m.find(prefSum[j]) == m.end()){
                m[prefSum[j]] = 0;
            }
            m[prefSum[j]]++;
        }
        
return count;
    }
    
};
